
/tmp/arduino_build_201076/attiny_short-squawker.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	0e c0       	rjmp	.+28     	; 0x1e <__ctors_end>
   2:	28 c0       	rjmp	.+80     	; 0x54 <__bad_interrupt>
   4:	27 c0       	rjmp	.+78     	; 0x54 <__bad_interrupt>
   6:	26 c0       	rjmp	.+76     	; 0x54 <__bad_interrupt>
   8:	25 c0       	rjmp	.+74     	; 0x54 <__bad_interrupt>
   a:	24 c0       	rjmp	.+72     	; 0x54 <__bad_interrupt>
   c:	23 c0       	rjmp	.+70     	; 0x54 <__bad_interrupt>
   e:	22 c0       	rjmp	.+68     	; 0x54 <__bad_interrupt>
  10:	21 c0       	rjmp	.+66     	; 0x54 <__bad_interrupt>
  12:	20 c0       	rjmp	.+64     	; 0x54 <__bad_interrupt>
  14:	20 c0       	rjmp	.+64     	; 0x56 <__vector_10>
  16:	1e c0       	rjmp	.+60     	; 0x54 <__bad_interrupt>
  18:	1d c0       	rjmp	.+58     	; 0x54 <__bad_interrupt>
  1a:	1c c0       	rjmp	.+56     	; 0x54 <__bad_interrupt>
  1c:	1b c0       	rjmp	.+54     	; 0x54 <__bad_interrupt>

0000001e <__ctors_end>:
__trampolines_start():
  1e:	11 24       	eor	r1, r1
  20:	1f be       	out	0x3f, r1	; 63
  22:	cf e5       	ldi	r28, 0x5F	; 95
  24:	d2 e0       	ldi	r29, 0x02	; 2
  26:	de bf       	out	0x3e, r29	; 62
  28:	cd bf       	out	0x3d, r28	; 61

0000002a <__do_copy_data>:
__do_copy_data():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  2a:	11 e0       	ldi	r17, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  2c:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  2e:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  30:	ea ef       	ldi	r30, 0xFA	; 250
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  32:	f3 e0       	ldi	r31, 0x03	; 3
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  34:	02 c0       	rjmp	.+4      	; 0x3a <__do_copy_data+0x10>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  36:	05 90       	lpm	r0, Z+
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  38:	0d 92       	st	X+, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  3a:	a2 36       	cpi	r26, 0x62	; 98
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  3c:	b1 07       	cpc	r27, r17
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  3e:	d9 f7       	brne	.-10     	; 0x36 <__do_copy_data+0xc>

00000040 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  40:	21 e0       	ldi	r18, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  42:	a2 e6       	ldi	r26, 0x62	; 98
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  44:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  46:	01 c0       	rjmp	.+2      	; 0x4a <.do_clear_bss_start>

00000048 <.do_clear_bss_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  48:	1d 92       	st	X+, r1

0000004a <.do_clear_bss_start>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  4a:	af 36       	cpi	r26, 0x6F	; 111
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  4c:	b2 07       	cpc	r27, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  4e:	e1 f7       	brne	.-8      	; 0x48 <.do_clear_bss_loop>
.do_clear_bss_start():
  50:	8a d1       	rcall	.+788    	; 0x366 <main>
  52:	d1 c1       	rjmp	.+930    	; 0x3f6 <_exit>

00000054 <__bad_interrupt>:
__vector_1():
  54:	d5 cf       	rjmp	.-86     	; 0x0 <__vectors>

00000056 <__vector_10>:
__vector_10():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:431

}
*/

ISR(TIMER0_COMPA_vect)
{
  56:	1f 92       	push	r1
  58:	0f 92       	push	r0
  5a:	0f b6       	in	r0, 0x3f	; 63
  5c:	0f 92       	push	r0
  5e:	11 24       	eor	r1, r1
  60:	2f 93       	push	r18
  62:	3f 93       	push	r19
  64:	4f 93       	push	r20
  66:	5f 93       	push	r21
  68:	6f 93       	push	r22
  6a:	7f 93       	push	r23
  6c:	8f 93       	push	r24
  6e:	9f 93       	push	r25
  70:	af 93       	push	r26
  72:	bf 93       	push	r27
  74:	cf 93       	push	r28
  76:	ef 93       	push	r30
  78:	ff 93       	push	r31
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:435
  static uint16_t timer_count = 0;
  uint16_t adc;

  PORTB |= DEBUG_PIN;  // measure ISR duration using this pin
  7a:	c0 9a       	sbi	0x18, 0	; 24
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:439

  // timing-sensitive things first
  // output sample value
  OCR1A = signal_synth(dco_phase >> 8);
  7c:	40 91 6d 01 	lds	r20, 0x016D	; 0x80016d <dco_phase>
  80:	50 91 6e 01 	lds	r21, 0x016E	; 0x80016e <dco_phase+0x1>
  84:	45 2f       	mov	r20, r21
  86:	55 27       	eor	r21, r21
  88:	c4 2f       	mov	r28, r20
wave_sine():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:345



int8_t wave_sine(uint8_t phase)
{
  return sine_table[phase] - 128;
  8a:	fa 01       	movw	r30, r20
  8c:	ee 59       	subi	r30, 0x9E	; 158
  8e:	ff 4f       	sbci	r31, 0xFF	; 255
  90:	20 81       	ld	r18, Z
  92:	20 58       	subi	r18, 0x80	; 128
signal_synth():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:358
  int16_t sig = 0;
  uint16_t x;

  // fundamental frequency
  x = 1 * phase;
  sig = wave_sine(x);
  94:	02 2e       	mov	r0, r18
  96:	00 0c       	add	r0, r0
  98:	33 0b       	sbc	r19, r19
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:361

  // 2nd harmonic
  if (average < (1024 * ADC_AVERAGE_GAIN / 2)) {
  9a:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <average>
  9e:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <average+0x1>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:362
    x += phase;
  a2:	fa 01       	movw	r30, r20
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:361
  // fundamental frequency
  x = 1 * phase;
  sig = wave_sine(x);

  // 2nd harmonic
  if (average < (1024 * ADC_AVERAGE_GAIN / 2)) {
  a4:	81 15       	cp	r24, r1
  a6:	90 42       	sbci	r25, 0x20	; 32
  a8:	a0 f4       	brcc	.+40     	; 0xd2 <__vector_10+0x7c>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:362
    x += phase;
  aa:	ee 0f       	add	r30, r30
  ac:	ff 1f       	adc	r31, r31
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:363
    sig += wave_sine(x & 0xff)/4;
  ae:	a4 2f       	mov	r26, r20
  b0:	aa 0f       	add	r26, r26
wave_sine():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:345



int8_t wave_sine(uint8_t phase)
{
  return sine_table[phase] - 128;
  b2:	b0 e0       	ldi	r27, 0x00	; 0
  b4:	ae 59       	subi	r26, 0x9E	; 158
  b6:	bf 4f       	sbci	r27, 0xFF	; 255
  b8:	9c 91       	ld	r25, X
  ba:	80 e8       	ldi	r24, 0x80	; 128
  bc:	89 0f       	add	r24, r25
signal_synth():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:363
  sig = wave_sine(x);

  // 2nd harmonic
  if (average < (1024 * ADC_AVERAGE_GAIN / 2)) {
    x += phase;
    sig += wave_sine(x & 0xff)/4;
  be:	87 ff       	sbrs	r24, 7
  c0:	02 c0       	rjmp	.+4      	; 0xc6 <__vector_10+0x70>
  c2:	83 e8       	ldi	r24, 0x83	; 131
  c4:	89 0f       	add	r24, r25
  c6:	85 95       	asr	r24
  c8:	85 95       	asr	r24
  ca:	28 0f       	add	r18, r24
  cc:	31 1d       	adc	r19, r1
  ce:	87 fd       	sbrc	r24, 7
  d0:	3a 95       	dec	r19
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:367
  }

  // 3rd harmonic
  if (average < (1024 * ADC_AVERAGE_GAIN / 3)) {
  d2:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <average>
  d6:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <average+0x1>
  da:	85 35       	cpi	r24, 0x55	; 85
  dc:	95 41       	sbci	r25, 0x15	; 21
  de:	70 f4       	brcc	.+28     	; 0xfc <__vector_10+0xa6>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:368
    x += phase;
  e0:	e4 0f       	add	r30, r20
  e2:	f5 1f       	adc	r31, r21
wave_sine():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:345



int8_t wave_sine(uint8_t phase)
{
  return sine_table[phase] - 128;
  e4:	df 01       	movw	r26, r30
  e6:	bb 27       	eor	r27, r27
  e8:	ae 59       	subi	r26, 0x9E	; 158
  ea:	bf 4f       	sbci	r27, 0xFF	; 255
  ec:	8c 91       	ld	r24, X
  ee:	80 58       	subi	r24, 0x80	; 128
signal_synth():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:369
  }

  // 3rd harmonic
  if (average < (1024 * ADC_AVERAGE_GAIN / 3)) {
    x += phase;
    sig += wave_sine(x & 0xff)/9;
  f0:	69 e0       	ldi	r22, 0x09	; 9
  f2:	68 d1       	rcall	.+720    	; 0x3c4 <__divmodqi4>
  f4:	28 0f       	add	r18, r24
  f6:	31 1d       	adc	r19, r1
  f8:	87 fd       	sbrc	r24, 7
  fa:	3a 95       	dec	r19
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:373
  }

  // 4rd harmonic
  if (average < (1024 * ADC_AVERAGE_GAIN / 4)) {
  fc:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <average>
 100:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <average+0x1>
 104:	81 15       	cp	r24, r1
 106:	90 41       	sbci	r25, 0x10	; 16
 108:	a8 f4       	brcc	.+42     	; 0x134 <__vector_10+0xde>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:374
    x += phase;
 10a:	e4 0f       	add	r30, r20
 10c:	f5 1f       	adc	r31, r21
wave_sine():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:345



int8_t wave_sine(uint8_t phase)
{
  return sine_table[phase] - 128;
 10e:	df 01       	movw	r26, r30
 110:	bb 27       	eor	r27, r27
 112:	ae 59       	subi	r26, 0x9E	; 158
 114:	bf 4f       	sbci	r27, 0xFF	; 255
 116:	9c 91       	ld	r25, X
 118:	80 e8       	ldi	r24, 0x80	; 128
 11a:	89 0f       	add	r24, r25
signal_synth():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:375
  }

  // 4rd harmonic
  if (average < (1024 * ADC_AVERAGE_GAIN / 4)) {
    x += phase;
    sig += wave_sine(x & 0xff)/16;
 11c:	87 ff       	sbrs	r24, 7
 11e:	02 c0       	rjmp	.+4      	; 0x124 <__vector_10+0xce>
 120:	8f e8       	ldi	r24, 0x8F	; 143
 122:	89 0f       	add	r24, r25
 124:	85 95       	asr	r24
 126:	85 95       	asr	r24
 128:	85 95       	asr	r24
 12a:	85 95       	asr	r24
 12c:	28 0f       	add	r18, r24
 12e:	31 1d       	adc	r19, r1
 130:	87 fd       	sbrc	r24, 7
 132:	3a 95       	dec	r19
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:379
  }

  // 4rd harmonic
  if (average < (1024 * ADC_AVERAGE_GAIN / 5)) {
 134:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <average>
 138:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <average+0x1>
 13c:	8c 3c       	cpi	r24, 0xCC	; 204
 13e:	9c 40       	sbci	r25, 0x0C	; 12
 140:	68 f4       	brcc	.+26     	; 0x15c <__vector_10+0x106>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:380
    x += phase;
 142:	e4 0f       	add	r30, r20
 144:	f5 1f       	adc	r31, r21
wave_sine():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:345



int8_t wave_sine(uint8_t phase)
{
  return sine_table[phase] - 128;
 146:	ff 27       	eor	r31, r31
 148:	ee 59       	subi	r30, 0x9E	; 158
 14a:	ff 4f       	sbci	r31, 0xFF	; 255
 14c:	80 81       	ld	r24, Z
 14e:	80 58       	subi	r24, 0x80	; 128
signal_synth():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:381
  }

  // 4rd harmonic
  if (average < (1024 * ADC_AVERAGE_GAIN / 5)) {
    x += phase;
    sig += wave_sine(x & 0xff)/20;
 150:	64 e1       	ldi	r22, 0x14	; 20
 152:	38 d1       	rcall	.+624    	; 0x3c4 <__divmodqi4>
 154:	28 0f       	add	r18, r24
 156:	31 1d       	adc	r19, r1
 158:	87 fd       	sbrc	r24, 7
 15a:	3a 95       	dec	r19
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:388

  sig = sig / 4;


  // sawtooth
  if (average < (1024 * ADC_AVERAGE_GAIN / 10)) {
 15c:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <average>
 160:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <average+0x1>
 164:	86 36       	cpi	r24, 0x66	; 102
 166:	96 40       	sbci	r25, 0x06	; 6
 168:	08 f4       	brcc	.+2      	; 0x16c <__vector_10+0x116>
 16a:	91 c0       	rjmp	.+290    	; 0x28e <__stack+0x2f>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:384
  if (average < (1024 * ADC_AVERAGE_GAIN / 5)) {
    x += phase;
    sig += wave_sine(x & 0xff)/20;
  }

  sig = sig / 4;
 16c:	37 ff       	sbrs	r19, 7
 16e:	02 c0       	rjmp	.+4      	; 0x174 <__vector_10+0x11e>
 170:	2d 5f       	subi	r18, 0xFD	; 253
 172:	3f 4f       	sbci	r19, 0xFF	; 255
 174:	35 95       	asr	r19
 176:	27 95       	ror	r18
 178:	35 95       	asr	r19
 17a:	27 95       	ror	r18
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:395
    sig = wave_triangle(phase)/3;
  }



  return (sig + 128) & 0xff;
 17c:	20 58       	subi	r18, 0x80	; 128
__vector_10():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:439

  PORTB |= DEBUG_PIN;  // measure ISR duration using this pin

  // timing-sensitive things first
  // output sample value
  OCR1A = signal_synth(dco_phase >> 8);
 17e:	2e bd       	out	0x2e, r18	; 46
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:448
  //OCR1A = wave_triangle(x);
  //OCR1A = wave_sawtooth(x);


  // then everything else
  timer_count++;
 180:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <__vector_10::timer_count>
 184:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <__vector_10::timer_count+0x1>
 188:	01 96       	adiw	r24, 0x01	; 1
 18a:	90 93 6c 01 	sts	0x016C, r25	; 0x80016c <__vector_10::timer_count+0x1>
 18e:	80 93 6b 01 	sts	0x016B, r24	; 0x80016b <__vector_10::timer_count>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:453


  // ADC and output update
  // TODO: is (now() - last_time > period) quicker?
  if ((timer_count + ADC_TICK_OFFSET) % ADC_PERIOD == 0) {
 192:	8f 70       	andi	r24, 0x0F	; 15
 194:	99 27       	eor	r25, r25
 196:	89 2b       	or	r24, r25
 198:	41 f5       	brne	.+80     	; 0x1ea <__vector_10+0x194>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:454
    adc = ADCL;
 19a:	24 b1       	in	r18, 0x04	; 4
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:455
    adc += (ADCH << 8);
 19c:	95 b1       	in	r25, 0x05	; 5
 19e:	89 2f       	mov	r24, r25
 1a0:	90 e0       	ldi	r25, 0x00	; 0
 1a2:	98 2f       	mov	r25, r24
 1a4:	88 27       	eor	r24, r24
 1a6:	28 0f       	add	r18, r24
 1a8:	39 2f       	mov	r19, r25
 1aa:	31 1d       	adc	r19, r1
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:456
    ADCSRA |= (1 << ADSC);
 1ac:	36 9a       	sbi	0x06, 6	; 6
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:459

    // always update phase increment ASAP
    if (adc >= 1020) {   // TODO: make this a config value
 1ae:	2c 3f       	cpi	r18, 0xFC	; 252
 1b0:	83 e0       	ldi	r24, 0x03	; 3
 1b2:	38 07       	cpc	r19, r24
 1b4:	08 f4       	brcc	.+2      	; 0x1b8 <__vector_10+0x162>
 1b6:	79 c0       	rjmp	.+242    	; 0x2aa <__stack+0x4b>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:465
      // Values close to this turns the sound on/off quickly and randomly,
      // which sounds scratchy.  Maybe better if the *filtered* input value is
      // used to detect open-circuit instead?

      // silent if sample is over-range
      phase_increment = 0;  // output a static duty cycle
 1b8:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1bc:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:475
      average = adc_average(adc);
      phase_increment = adc_to_phase_increment(average);
    }

    if (alternate_tone
        && ((timer_count % ALTERNATE_PERIOD) < (ALTERNATE_PERIOD / 4))) {
 1c0:	80 91 68 01 	lds	r24, 0x0168	; 0x800168 <alternate_tone>
 1c4:	88 23       	and	r24, r24
 1c6:	89 f0       	breq	.+34     	; 0x1ea <__vector_10+0x194>
 1c8:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <__vector_10::timer_count>
 1cc:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <__vector_10::timer_count+0x1>
 1d0:	9f 70       	andi	r25, 0x0F	; 15
 1d2:	81 15       	cp	r24, r1
 1d4:	94 40       	sbci	r25, 0x04	; 4
 1d6:	48 f4       	brcc	.+18     	; 0x1ea <__vector_10+0x194>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:477
      // alternate between reference and live values
      phase_increment = adc_to_phase_increment(zero_reference);
 1d8:	80 91 66 01 	lds	r24, 0x0166	; 0x800166 <zero_reference>
 1dc:	90 91 67 01 	lds	r25, 0x0167	; 0x800167 <zero_reference+0x1>
adc_to_phase_increment():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:280
uint16_t adc_to_phase_increment(uint16_t value)
{
  // TODO: document these constants
  // minimum frequency for ADC value of 0, offset
  // maximum frequency for largest ADC value, scale factor
  return (16/ADC_AVERAGE_GAIN * value) + PHASE_INC_MIN;
 1e0:	9c 5f       	subi	r25, 0xFC	; 252
__vector_10():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:477
    }

    if (alternate_tone
        && ((timer_count % ALTERNATE_PERIOD) < (ALTERNATE_PERIOD / 4))) {
      // alternate between reference and live values
      phase_increment = adc_to_phase_increment(zero_reference);
 1e2:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1e6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:484
  } // ADC


  // DCO update
  // (after possible ADC for lower response latency)
  dco_phase += phase_increment;
 1ea:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 1ee:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1f2:	80 91 6d 01 	lds	r24, 0x016D	; 0x80016d <dco_phase>
 1f6:	90 91 6e 01 	lds	r25, 0x016E	; 0x80016e <dco_phase+0x1>
 1fa:	82 0f       	add	r24, r18
 1fc:	93 1f       	adc	r25, r19
 1fe:	90 93 6e 01 	sts	0x016E, r25	; 0x80016e <dco_phase+0x1>
 202:	80 93 6d 01 	sts	0x016D, r24	; 0x80016d <dco_phase>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:488


  // Input handling
  if ((timer_count + INPUT_TICK_OFFSET) % INPUT_PERIOD == 0) {
 206:	80 91 6b 01 	lds	r24, 0x016B	; 0x80016b <__vector_10::timer_count>
 20a:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <__vector_10::timer_count+0x1>
 20e:	01 96       	adiw	r24, 0x01	; 1
 210:	8f 71       	andi	r24, 0x1F	; 31
 212:	99 27       	eor	r25, r25
 214:	89 2b       	or	r24, r25
 216:	09 f0       	breq	.+2      	; 0x21a <__vector_10+0x1c4>
 218:	8a c0       	rjmp	.+276    	; 0x32e <__stack+0xcf>
SM_input():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:203
void SM_input()
{
  static int SM_input_state = button_up;
  static unsigned int count = 0;

  uint8_t button = PINB & BUTTON_PIN;
 21a:	86 b3       	in	r24, 0x16	; 22
 21c:	84 70       	andi	r24, 0x04	; 4
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:206

  // transitions
  switch (SM_input_state) {
 21e:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <SM_input()::SM_input_state>
 222:	30 91 65 01 	lds	r19, 0x0165	; 0x800165 <SM_input()::SM_input_state+0x1>
 226:	21 30       	cpi	r18, 0x01	; 1
 228:	31 05       	cpc	r19, r1
 22a:	09 f4       	brne	.+2      	; 0x22e <__vector_10+0x1d8>
 22c:	65 c0       	rjmp	.+202    	; 0x2f8 <__stack+0x99>
 22e:	22 30       	cpi	r18, 0x02	; 2
 230:	31 05       	cpc	r19, r1
 232:	09 f4       	brne	.+2      	; 0x236 <__vector_10+0x1e0>
 234:	6b c0       	rjmp	.+214    	; 0x30c <__stack+0xad>
 236:	23 2b       	or	r18, r19
 238:	09 f0       	breq	.+2      	; 0x23c <__vector_10+0x1e6>
 23a:	6b c0       	rjmp	.+214    	; 0x312 <__stack+0xb3>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:208
    case button_up:
      if (button) {
 23c:	81 11       	cpse	r24, r1
 23e:	06 c0       	rjmp	.+12     	; 0x24c <__vector_10+0x1f6>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:211
        SM_input_state = button_up;
      } else {
        SM_input_state = button_down;
 240:	81 e0       	ldi	r24, 0x01	; 1
 242:	90 e0       	ldi	r25, 0x00	; 0
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:217
      }
      break;

    case button_down:
      if (count > BUTTON_HOLD_TIMEOUT) {
        SM_input_state = timeout;
 244:	90 93 65 01 	sts	0x0165, r25	; 0x800165 <SM_input()::SM_input_state+0x1>
 248:	80 93 64 01 	sts	0x0164, r24	; 0x800164 <SM_input()::SM_input_state>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:242
      SM_input_state = button_up;
      break;
  }

  // actions
  switch (SM_input_state) {
 24c:	80 91 64 01 	lds	r24, 0x0164	; 0x800164 <SM_input()::SM_input_state>
 250:	90 91 65 01 	lds	r25, 0x0165	; 0x800165 <SM_input()::SM_input_state+0x1>
 254:	81 30       	cpi	r24, 0x01	; 1
 256:	91 05       	cpc	r25, r1
 258:	09 f4       	brne	.+2      	; 0x25c <__vector_10+0x206>
 25a:	60 c0       	rjmp	.+192    	; 0x31c <__stack+0xbd>
 25c:	82 30       	cpi	r24, 0x02	; 2
 25e:	91 05       	cpc	r25, r1
 260:	09 f4       	brne	.+2      	; 0x264 <__stack+0x5>
 262:	78 c0       	rjmp	.+240    	; 0x354 <__stack+0xf5>
 264:	89 2b       	or	r24, r25
 266:	09 f0       	breq	.+2      	; 0x26a <__stack+0xb>
 268:	62 c0       	rjmp	.+196    	; 0x32e <__stack+0xcf>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:244
    case button_up:
      if (count >= 1) {
 26a:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <__data_end>
 26e:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <__data_end+0x1>
 272:	89 2b       	or	r24, r25
 274:	09 f4       	brne	.+2      	; 0x278 <__stack+0x19>
 276:	5b c0       	rjmp	.+182    	; 0x32e <__stack+0xcf>
toggle_alternate_tone():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:190
  }
  else {
    alternate_tone = 1;
  }
  */
  alternate_tone ^= 1;
 278:	80 91 68 01 	lds	r24, 0x0168	; 0x800168 <alternate_tone>
 27c:	91 e0       	ldi	r25, 0x01	; 1
 27e:	89 27       	eor	r24, r25
 280:	80 93 68 01 	sts	0x0168, r24	; 0x800168 <alternate_tone>
SM_input():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:256
      count++;
      break;

    case timeout:
      set_zero_reference(average);
      count = 0;
 284:	10 92 63 01 	sts	0x0163, r1	; 0x800163 <__data_end+0x1>
 288:	10 92 62 01 	sts	0x0162, r1	; 0x800162 <__data_end>
 28c:	50 c0       	rjmp	.+160    	; 0x32e <__stack+0xcf>
wave_triangle():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:299
int8_t wave_triangle(uint8_t phase)
{
  uint8_t x = (4 * phase) & 0xff;

  if (phase > 63) {
    return 127 - (phase - 64);
 28e:	8f eb       	ldi	r24, 0xBF	; 191
 290:	84 1b       	sub	r24, r20
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:298

int8_t wave_triangle(uint8_t phase)
{
  uint8_t x = (4 * phase) & 0xff;

  if (phase > 63) {
 292:	c0 34       	cpi	r28, 0x40	; 64
 294:	20 f4       	brcc	.+8      	; 0x29e <__stack+0x3f>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:301
    return 127 - (phase - 64);
  } else {
    return (4 * phase - 128);
 296:	80 ee       	ldi	r24, 0xE0	; 224
 298:	84 0f       	add	r24, r20
 29a:	88 0f       	add	r24, r24
 29c:	88 0f       	add	r24, r24
signal_synth():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:390


  // sawtooth
  if (average < (1024 * ADC_AVERAGE_GAIN / 10)) {
    //sig = (255 - phase - 128)/4;
    sig = wave_triangle(phase)/3;
 29e:	63 e0       	ldi	r22, 0x03	; 3
 2a0:	91 d0       	rcall	.+290    	; 0x3c4 <__divmodqi4>
 2a2:	28 2f       	mov	r18, r24
 2a4:	88 0f       	add	r24, r24
 2a6:	33 0b       	sbc	r19, r19
 2a8:	69 cf       	rjmp	.-302    	; 0x17c <__vector_10+0x126>
adc_average():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:270



uint16_t adc_average(uint16_t value)
{
  average = value + (average - average / ADC_AVERAGE_GAIN);
 2aa:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <average>
 2ae:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <average+0x1>
 2b2:	40 91 69 01 	lds	r20, 0x0169	; 0x800169 <average>
 2b6:	50 91 6a 01 	lds	r21, 0x016A	; 0x80016a <average+0x1>
 2ba:	64 e0       	ldi	r22, 0x04	; 4
 2bc:	56 95       	lsr	r21
 2be:	47 95       	ror	r20
 2c0:	6a 95       	dec	r22
 2c2:	e1 f7       	brne	.-8      	; 0x2bc <__stack+0x5d>
 2c4:	84 1b       	sub	r24, r20
 2c6:	95 0b       	sbc	r25, r21
 2c8:	82 0f       	add	r24, r18
 2ca:	93 1f       	adc	r25, r19
 2cc:	90 93 6a 01 	sts	0x016A, r25	; 0x80016a <average+0x1>
 2d0:	80 93 69 01 	sts	0x0169, r24	; 0x800169 <average>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:271
  return average;
 2d4:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <average>
 2d8:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <average+0x1>
__vector_10():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:470
      phase_increment = 0;  // output a static duty cycle
      // TODO: Better is to just shut down the timer.
    }
    else {
      // Low-pass filter the raw ADC value.
      average = adc_average(adc);
 2dc:	90 93 6a 01 	sts	0x016A, r25	; 0x80016a <average+0x1>
 2e0:	80 93 69 01 	sts	0x0169, r24	; 0x800169 <average>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:471
      phase_increment = adc_to_phase_increment(average);
 2e4:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <average>
 2e8:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <average+0x1>
adc_to_phase_increment():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:280
uint16_t adc_to_phase_increment(uint16_t value)
{
  // TODO: document these constants
  // minimum frequency for ADC value of 0, offset
  // maximum frequency for largest ADC value, scale factor
  return (16/ADC_AVERAGE_GAIN * value) + PHASE_INC_MIN;
 2ec:	9c 5f       	subi	r25, 0xFC	; 252
__vector_10():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:471
      // TODO: Better is to just shut down the timer.
    }
    else {
      // Low-pass filter the raw ADC value.
      average = adc_average(adc);
      phase_increment = adc_to_phase_increment(average);
 2ee:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 2f2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 2f6:	64 cf       	rjmp	.-312    	; 0x1c0 <__vector_10+0x16a>
SM_input():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:216
        SM_input_state = button_down;
      }
      break;

    case button_down:
      if (count > BUTTON_HOLD_TIMEOUT) {
 2f8:	20 91 62 01 	lds	r18, 0x0162	; 0x800162 <__data_end>
 2fc:	30 91 63 01 	lds	r19, 0x0163	; 0x800163 <__data_end+0x1>
 300:	21 39       	cpi	r18, 0x91	; 145
 302:	31 40       	sbci	r19, 0x01	; 1
 304:	18 f0       	brcs	.+6      	; 0x30c <__stack+0xad>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:217
        SM_input_state = timeout;
 306:	82 e0       	ldi	r24, 0x02	; 2
 308:	90 e0       	ldi	r25, 0x00	; 0
 30a:	9c cf       	rjmp	.-200    	; 0x244 <__vector_10+0x1ee>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:219
      }
      else if (button) {
 30c:	88 23       	and	r24, r24
 30e:	09 f4       	brne	.+2      	; 0x312 <__stack+0xb3>
 310:	9d cf       	rjmp	.-198    	; 0x24c <__vector_10+0x1f6>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:237
        SM_input_state = timeout;
      }
      break;

    default:
      SM_input_state = button_up;
 312:	10 92 65 01 	sts	0x0165, r1	; 0x800165 <SM_input()::SM_input_state+0x1>
 316:	10 92 64 01 	sts	0x0164, r1	; 0x800164 <SM_input()::SM_input_state>
 31a:	98 cf       	rjmp	.-208    	; 0x24c <__vector_10+0x1f6>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:251
        count = 0;
      }
      break;

    case button_down:
      count++;
 31c:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <__data_end>
 320:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <__data_end+0x1>
 324:	01 96       	adiw	r24, 0x01	; 1
 326:	90 93 63 01 	sts	0x0163, r25	; 0x800163 <__data_end+0x1>
 32a:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <__data_end>
__vector_10():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:492
  // Input handling
  if ((timer_count + INPUT_TICK_OFFSET) % INPUT_PERIOD == 0) {
    SM_input();
  }

  PORTB &= ~DEBUG_PIN;  // pulse width is ISR duration
 32e:	c0 98       	cbi	0x18, 0	; 24
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:493
} // TIMER0_COMPA_vect
 330:	ff 91       	pop	r31
 332:	ef 91       	pop	r30
 334:	cf 91       	pop	r28
 336:	bf 91       	pop	r27
 338:	af 91       	pop	r26
 33a:	9f 91       	pop	r25
 33c:	8f 91       	pop	r24
 33e:	7f 91       	pop	r23
 340:	6f 91       	pop	r22
 342:	5f 91       	pop	r21
 344:	4f 91       	pop	r20
 346:	3f 91       	pop	r19
 348:	2f 91       	pop	r18
 34a:	0f 90       	pop	r0
 34c:	0f be       	out	0x3f, r0	; 63
 34e:	0f 90       	pop	r0
 350:	1f 90       	pop	r1
 352:	18 95       	reti
SM_input():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:255
    case button_down:
      count++;
      break;

    case timeout:
      set_zero_reference(average);
 354:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <average>
 358:	90 91 6a 01 	lds	r25, 0x016A	; 0x80016a <average+0x1>
set_zero_reference():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:174



void set_zero_reference(uint16_t value)
{
  zero_reference = value;
 35c:	90 93 67 01 	sts	0x0167, r25	; 0x800167 <zero_reference+0x1>
 360:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <zero_reference>
 364:	8f cf       	rjmp	.-226    	; 0x284 <__stack+0x25>

00000366 <main>:
main():
/home/dan/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 366:	83 e0       	ldi	r24, 0x03	; 3
 368:	8a bd       	out	0x2a, r24	; 42
/home/dan/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 36a:	83 bf       	out	0x33, r24	; 51
/home/dan/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 36c:	78 94       	sei
initToneTimerInternal():
/home/dan/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:958
    #elif defined(__AVR_ATtiny43__)
      TCCR1A = 3; //WGM 10=1, WGM11=1
      TCCR1B = 3; //prescaler of 64
    #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1) // ATtiny x5
      // Use the Tone Timer for fast PWM as phase correct not supported by this timer
      GTCCR = (1<<PWM1B);
 36e:	80 e4       	ldi	r24, 0x40	; 64
 370:	8c bd       	out	0x2c, r24	; 44
/home/dan/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:959
      OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
 372:	9f ef       	ldi	r25, 0xFF	; 255
 374:	9d bd       	out	0x2d, r25	; 45
/home/dan/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:960
      TCCR1 = (1<<CTC1) | (1<<PWM1A) | (ToneTimer_Prescale_Index << CS10);
 376:	87 ec       	ldi	r24, 0xC7	; 199
 378:	80 bf       	out	0x30, r24	; 48
main():
/home/dan/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tiny/wiring.c:1214
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      // ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
      // dude, this is being called on startup. We know that ADCSRA is 0! Why add a RMW cycle?!
      ADCSRA = (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 37a:	86 e8       	ldi	r24, 0x86	; 134
 37c:	86 b9       	out	0x06, r24	; 6
pin_setup():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:162



void pin_setup()
{
  DDRB |= OUTPUT_PIN;
 37e:	b9 9a       	sbi	0x17, 1	; 23
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:163
  DDRB |= DEBUG_PIN;
 380:	b8 9a       	sbi	0x17, 0	; 23
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:165

  DDRB &= ~BUTTON_PIN;
 382:	ba 98       	cbi	0x17, 2	; 23
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:166
  PORTB |= BUTTON_PIN;
 384:	c2 9a       	sbi	0x18, 2	; 24
timer_setup():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:97
void timer_setup()
{
  /*
   * Timer0 setup
   */
  GTCCR = 0x00; //default
 386:	1c bc       	out	0x2c, r1	; 44
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:98
  TCCR0A = (0x2 << WGM00);
 388:	82 e0       	ldi	r24, 0x02	; 2
 38a:	8a bd       	out	0x2a, r24	; 42
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:100

  TCCR0B = TIMER0_PRESCALER_DIV8;
 38c:	83 bf       	out	0x33, r24	; 51
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:102

  OCR0A = TIMER0_MAX;
 38e:	83 e6       	ldi	r24, 0x63	; 99
 390:	89 bd       	out	0x29, r24	; 41
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:107

  // interrupt on OCR0A match

  // enable overflow interrupt
  TIMSK = 0x00;  // default
 392:	19 be       	out	0x39, r1	; 57
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:108
  TIMSK |= (1 << OCIE0A);
 394:	89 b7       	in	r24, 0x39	; 57
 396:	80 61       	ori	r24, 0x10	; 16
 398:	89 bf       	out	0x39, r24	; 57
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:113

  /*
   * Timer1 setup
   */
  TCCR1 = (1 << CTC1)  // clear timer on OCR1C match
 39a:	81 ee       	ldi	r24, 0xE1	; 225
 39c:	80 bf       	out	0x30, r24	; 48
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:119
         + (1 << PWM1A)   // PWM mode for OCR1A
         + (0b10 << COM1A0)  // both OC1A and OC1Ainv active
         + (0x01);  // CS1[3:0] clock select

  // longest PWM period
  OCR1C = 0xff;
 39e:	9d bd       	out	0x2d, r25	; 45
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:126
  /* 12.2.1 Initialization for Async Mode:
   * enable PLL
   * wait 100us
   * poll PLOCK for 1
   * set PCKE */
  PLLCSR |= (1 << PLLE);
 3a0:	87 b5       	in	r24, 0x27	; 39
 3a2:	82 60       	ori	r24, 0x02	; 2
 3a4:	87 bd       	out	0x27, r24	; 39
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:128

  while ((PLLCSR & (1 << PLOCK)) == 0) {
 3a6:	07 b4       	in	r0, 0x27	; 39
 3a8:	00 fe       	sbrs	r0, 0
 3aa:	fd cf       	rjmp	.-6      	; 0x3a6 <main+0x40>
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:131
    // wait here until the PLOCK bit goes high
  }
  PLLCSR |= (1 << PCKE);
 3ac:	87 b5       	in	r24, 0x27	; 39
 3ae:	84 60       	ori	r24, 0x04	; 4
 3b0:	87 bd       	out	0x27, r24	; 39
adc_setup():
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:137
}


void adc_setup()
{
  ADMUX = ADC_REF_INTERNAL_1V1 +
 3b2:	86 e8       	ldi	r24, 0x86	; 134
 3b4:	87 b9       	out	0x07, r24	; 7
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:145

  // div 64 from system clock
  // f_cpu 8 MHz / 64 => 125 kHz
  const uint8_t ADC_PRESCALER = 0x06;

  ADCSRA = (1 << ADEN) +
 3b6:	86 ec       	ldi	r24, 0xC6	; 198
 3b8:	86 b9       	out	0x06, r24	; 6
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:152
           (0 << ADATE) +
           (0 << ADIE) +
           ADC_PRESCALER;

  // trigger conversion on timer0 overflow
  ADCSRB = 0x04;
 3ba:	84 e0       	ldi	r24, 0x04	; 4
 3bc:	83 b9       	out	0x03, r24	; 3
/home/dan/Arduino/attiny_short-squawker/attiny_short-squawker.ino:155

  // disable digital port buffers on
  DIDR0 = (1 << ADC2D) | (1 << ADC3D);
 3be:	88 e1       	ldi	r24, 0x18	; 24
 3c0:	84 bb       	out	0x14, r24	; 20
 3c2:	ff cf       	rjmp	.-2      	; 0x3c2 <main+0x5c>

000003c4 <__divmodqi4>:
__divmodqi4():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1366
 3c4:	87 fb       	bst	r24, 7
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1367
 3c6:	08 2e       	mov	r0, r24
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1368
 3c8:	06 26       	eor	r0, r22
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1369
 3ca:	87 fd       	sbrc	r24, 7
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1370
 3cc:	81 95       	neg	r24
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1371
 3ce:	67 fd       	sbrc	r22, 7
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1372
 3d0:	61 95       	neg	r22
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1373
 3d2:	05 d0       	rcall	.+10     	; 0x3de <__udivmodqi4>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1374
 3d4:	0e f4       	brtc	.+2      	; 0x3d8 <__divmodqi4_1>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1375
 3d6:	91 95       	neg	r25

000003d8 <__divmodqi4_1>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1377
 3d8:	07 fc       	sbrc	r0, 7
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1378
 3da:	81 95       	neg	r24

000003dc <__divmodqi4_exit>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1380
 3dc:	08 95       	ret

000003de <__udivmodqi4>:
__udivmodqi4():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1346
 3de:	99 1b       	sub	r25, r25
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1347
 3e0:	79 e0       	ldi	r23, 0x09	; 9
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1348
 3e2:	04 c0       	rjmp	.+8      	; 0x3ec <__udivmodqi4_ep>

000003e4 <__udivmodqi4_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1350
 3e4:	99 1f       	adc	r25, r25
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1351
 3e6:	96 17       	cp	r25, r22
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1352
 3e8:	08 f0       	brcs	.+2      	; 0x3ec <__udivmodqi4_ep>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1353
 3ea:	96 1b       	sub	r25, r22

000003ec <__udivmodqi4_ep>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1355
 3ec:	88 1f       	adc	r24, r24
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1356
 3ee:	7a 95       	dec	r23
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1357
 3f0:	c9 f7       	brne	.-14     	; 0x3e4 <__udivmodqi4_loop>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1358
 3f2:	80 95       	com	r24
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1360
 3f4:	08 95       	ret

000003f6 <_exit>:
exit():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 3f6:	f8 94       	cli

000003f8 <__stop_program>:
__stop_program():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 3f8:	ff cf       	rjmp	.-2      	; 0x3f8 <__stop_program>
